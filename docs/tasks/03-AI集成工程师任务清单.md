# ğŸ¤– AIé›†æˆå·¥ç¨‹å¸ˆä»»åŠ¡æ¸…å•

## ğŸ‘¤ è§’è‰²èŒè´£
**è´Ÿè´£äºº**: AIé›†æˆå·¥ç¨‹å¸ˆ (ai-integration-engineer)
**æ ¸å¿ƒä½¿å‘½**: å®ç°PromptXé›†æˆï¼Œæ‰“é€ æ™ºèƒ½å¯¹è¯ä½“éªŒ
**æ—¶é—´åˆ†é…**: 15åˆ†é’ŸPromptXé›†æˆ + 10åˆ†é’Ÿå¯¹è¯å¼•æ“

## ğŸ“‹ è¯¦ç»†ä»»åŠ¡åˆ†è§£

### Phase 1: PromptXå¥³å¨²è§’è‰²é›†æˆ (8åˆ†é’Ÿ)

#### ä»»åŠ¡1.1: PromptX MCPè¿æ¥å»ºç«‹ (3åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/promptx/client.ts
export class PromptXMCPClient {
  private mcpEndpoint: string;
  private apiKey: string;
  private isConnected: boolean = false;
  
  constructor() {
    this.mcpEndpoint = process.env.NEXT_PUBLIC_PROMPTX_MCP_ENDPOINT!;
    this.apiKey = process.env.NEXT_PUBLIC_PROMPTX_API_KEY!;
  }
  
  // å»ºç«‹MCPè¿æ¥
  async connect(): Promise<void> {
    try {
      const response = await fetch(`${this.mcpEndpoint}/health`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        throw new Error(`MCP connection failed: ${response.status}`);
      }
      
      this.isConnected = true;
      console.log('âœ… PromptX MCP connected successfully');
    } catch (error) {
      console.error('âŒ PromptX MCP connection failed:', error);
      throw error;
    }
  }
  
  // æ£€æŸ¥è¿æ¥çŠ¶æ€
  isHealthy(): boolean {
    return this.isConnected;
  }
}
```

**éªŒæ”¶æ ‡å‡†**:
- âœ… MCPè¿æ¥æˆåŠŸå»ºç«‹
- âœ… å¥åº·æ£€æŸ¥é€šè¿‡
- âœ… é”™è¯¯å¤„ç†å®Œæ•´
- âœ… è¿æ¥çŠ¶æ€å¯ç›‘æ§

#### ä»»åŠ¡1.2: å¥³å¨²è§’è‰²æ¿€æ´» (3åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/promptx/nuwa.ts
export class NuwaRoleManager {
  private client: PromptXMCPClient;
  private isActivated: boolean = false;
  
  constructor(client: PromptXMCPClient) {
    this.client = client;
  }
  
  // æ¿€æ´»å¥³å¨²è§’è‰²
  async activateNuwa(): Promise<void> {
    if (!this.client.isHealthy()) {
      throw new Error('MCP client not connected');
    }
    
    try {
      const response = await fetch(`${this.client.mcpEndpoint}/action`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.client.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          role: 'nuwa',
          parameters: {
            creativity: 0.9,
            professionalism: 0.8,
            adaptability: 0.9,
          },
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Nuwa activation failed: ${response.status}`);
      }
      
      const result = await response.json();
      this.isActivated = true;
      
      console.log('âœ… Nuwa role activated:', result);
      return result;
    } catch (error) {
      console.error('âŒ Nuwa activation failed:', error);
      throw error;
    }
  }
  
  // æ£€æŸ¥å¥³å¨²çŠ¶æ€
  isNuwaActive(): boolean {
    return this.isActivated;
  }
}
```

#### ä»»åŠ¡1.3: AIé¢è¯•å®˜ç”Ÿæˆæ ¸å¿ƒé€»è¾‘ (2åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/promptx/interviewer-generator.ts
export class InterviewerGenerator {
  private nuwaManager: NuwaRoleManager;
  
  constructor(nuwaManager: NuwaRoleManager) {
    this.nuwaManager = nuwaManager;
  }
  
  // ç”ŸæˆAIé¢è¯•å®˜
  async generateInterviewer(jobRequirement: JobRequirement): Promise<InterviewerProfile> {
    if (!this.nuwaManager.isNuwaActive()) {
      await this.nuwaManager.activateNuwa();
    }
    
    const prompt = this.buildGenerationPrompt(jobRequirement);
    
    try {
      const response = await fetch(`${this.client.mcpEndpoint}/generate`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.client.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          type: 'interviewer',
          prompt: prompt,
          parameters: {
            temperature: 0.8,
            max_tokens: 2000,
            response_format: 'structured',
          },
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Interviewer generation failed: ${response.status}`);
      }
      
      const rawResult = await response.json();
      return this.parseInterviewerResult(rawResult);
    } catch (error) {
      console.error('âŒ Interviewer generation failed:', error);
      throw error;
    }
  }
  
  // æ„å»ºç”Ÿæˆæç¤ºè¯
  private buildGenerationPrompt(job: JobRequirement): string {
    return `
åŸºäºä»¥ä¸‹å²—ä½éœ€æ±‚ï¼Œåˆ›é€ ä¸€ä¸ªä¸“ä¸šçš„AIé¢è¯•å®˜ï¼š

å²—ä½ä¿¡æ¯ï¼š
- èŒä½ï¼š${job.position}
- ç»éªŒè¦æ±‚ï¼š${job.experience}
- æŠ€èƒ½è¦æ±‚ï¼š${job.skills.join(', ')}
- çº§åˆ«ï¼š${job.level}
- è¯¦ç»†æè¿°ï¼š${job.description}

è¯·ç”Ÿæˆä¸€ä¸ªå…·æœ‰ä»¥ä¸‹ç‰¹å¾çš„é¢è¯•å®˜ï¼š
1. ä¸“ä¸šèƒŒæ™¯ä¸å²—ä½é«˜åº¦åŒ¹é…
2. å…·æœ‰ç‹¬ç‰¹çš„é¢è¯•é£æ ¼å’Œäººæ ¼ç‰¹ç‚¹
3. å‡†å¤‡äº†é’ˆå¯¹æ€§çš„é¢è¯•é—®é¢˜åº“
4. èƒ½å¤Ÿè¿›è¡Œæ·±åº¦æŠ€æœ¯å’Œè¡Œä¸ºé¢è¯•

è¾“å‡ºæ ¼å¼ï¼šJSONç»“æ„ï¼ŒåŒ…å«name, background, expertise, personality, questionsç­‰å­—æ®µ
    `;
  }
  
  // è§£æç”Ÿæˆç»“æœ
  private parseInterviewerResult(rawResult: any): InterviewerProfile {
    return {
      id: generateId(),
      name: rawResult.name || 'é¢è¯•å®˜',
      background: rawResult.background || 'èµ„æ·±ä¸“ä¸šäººå£«',
      expertise: rawResult.expertise || [],
      personality: rawResult.personality || 'ä¸“ä¸šä¸¥è°¨',
      avatar: this.generateAvatar(rawResult.name),
      questions: rawResult.questions || [],
      createdAt: new Date(),
    };
  }
  
  // ç”Ÿæˆå¤´åƒ
  private generateAvatar(name: string): string {
    // ä½¿ç”¨å¤´åƒç”ŸæˆæœåŠ¡æˆ–é»˜è®¤å¤´åƒ
    return `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(name)}`;
  }
}
```

### Phase 2: æ™ºèƒ½å¯¹è¯å¼•æ“å¼€å‘ (7åˆ†é’Ÿ)

#### ä»»åŠ¡2.1: å¯¹è¯ä¸Šä¸‹æ–‡ç®¡ç† (3åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/ai/conversation-manager.ts
export class ConversationManager {
  private messages: ChatMessage[] = [];
  private context: ConversationContext;
  private interviewer: InterviewerProfile;
  
  constructor(interviewer: InterviewerProfile) {
    this.interviewer = interviewer;
    this.context = {
      currentTopic: 'introduction',
      askedQuestions: [],
      candidateProfile: {},
      interviewPhase: 'opening',
    };
  }
  
  // æ·»åŠ æ¶ˆæ¯åˆ°å¯¹è¯å†å²
  addMessage(message: ChatMessage): void {
    this.messages.push(message);
    this.updateContext(message);
  }
  
  // æ›´æ–°å¯¹è¯ä¸Šä¸‹æ–‡
  private updateContext(message: ChatMessage): void {
    if (message.role === 'candidate') {
      // åˆ†æå€™é€‰äººå›ç­”ï¼Œæ›´æ–°ç”»åƒ
      this.analyzeCandidateResponse(message.content);
    }
    
    // æ›´æ–°é¢è¯•é˜¶æ®µ
    this.updateInterviewPhase();
  }
  
  // åˆ†æå€™é€‰äººå›ç­”
  private analyzeCandidateResponse(content: string): void {
    // æå–å…³é”®ä¿¡æ¯
    const keywords = this.extractKeywords(content);
    const sentiment = this.analyzeSentiment(content);
    const confidence = this.assessConfidence(content);
    
    // æ›´æ–°å€™é€‰äººç”»åƒ
    this.context.candidateProfile = {
      ...this.context.candidateProfile,
      keywords: [...(this.context.candidateProfile.keywords || []), ...keywords],
      averageSentiment: sentiment,
      confidenceLevel: confidence,
    };
  }
  
  // è·å–å¯¹è¯å†å²
  getMessages(): ChatMessage[] {
    return this.messages;
  }
  
  // è·å–å½“å‰ä¸Šä¸‹æ–‡
  getContext(): ConversationContext {
    return this.context;
  }
}
```

#### ä»»åŠ¡2.2: æ™ºèƒ½è¿½é—®é€»è¾‘ (2åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/ai/follow-up-generator.ts
export class FollowUpGenerator {
  private conversationManager: ConversationManager;
  private promptxClient: PromptXMCPClient;
  
  constructor(conversationManager: ConversationManager, promptxClient: PromptXMCPClient) {
    this.conversationManager = conversationManager;
    this.promptxClient = promptxClient;
  }
  
  // ç”Ÿæˆæ™ºèƒ½è¿½é—®
  async generateFollowUp(lastResponse: string): Promise<string> {
    const context = this.conversationManager.getContext();
    const messages = this.conversationManager.getMessages();
    
    const prompt = this.buildFollowUpPrompt(lastResponse, context, messages);
    
    try {
      const response = await fetch(`${this.promptxClient.mcpEndpoint}/chat`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.promptxClient.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [
            { role: 'system', content: prompt },
            { role: 'user', content: lastResponse },
          ],
          parameters: {
            temperature: 0.7,
            max_tokens: 500,
          },
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Follow-up generation failed: ${response.status}`);
      }
      
      const result = await response.json();
      return result.content;
    } catch (error) {
      console.error('âŒ Follow-up generation failed:', error);
      return this.getFallbackQuestion(context);
    }
  }
  
  // æ„å»ºè¿½é—®æç¤ºè¯
  private buildFollowUpPrompt(
    lastResponse: string, 
    context: ConversationContext, 
    messages: ChatMessage[]
  ): string {
    return `
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„é¢è¯•å®˜ï¼Œæ­£åœ¨è¿›è¡ŒæŠ€æœ¯é¢è¯•ã€‚

å½“å‰é¢è¯•é˜¶æ®µï¼š${context.interviewPhase}
å·²é—®é—®é¢˜ï¼š${context.askedQuestions.join(', ')}
å€™é€‰äººç”»åƒï¼š${JSON.stringify(context.candidateProfile)}

å€™é€‰äººåˆšæ‰çš„å›ç­”ï¼š${lastResponse}

è¯·åŸºäºå€™é€‰äººçš„å›ç­”ï¼Œç”Ÿæˆä¸€ä¸ªæ™ºèƒ½çš„è¿½é—®é—®é¢˜ï¼Œè¦æ±‚ï¼š
1. æ·±å…¥æŒ–æ˜å€™é€‰äººçš„æŠ€æœ¯èƒ½åŠ›æˆ–ç»éªŒ
2. é’ˆå¯¹å›ç­”ä¸­çš„å…³é”®ç‚¹è¿›è¡Œæ¢è®¨
3. ä¿æŒä¸“ä¸šå’Œå‹å¥½çš„è¯­è°ƒ
4. é¿å…é‡å¤å·²é—®è¿‡çš„é—®é¢˜

è¯·ç›´æ¥è¿”å›è¿½é—®é—®é¢˜ï¼Œä¸è¦åŒ…å«å…¶ä»–å†…å®¹ã€‚
    `;
  }
  
  // è·å–å¤‡ç”¨é—®é¢˜
  private getFallbackQuestion(context: ConversationContext): string {
    const fallbackQuestions = [
      'èƒ½è¯¦ç»†è¯´è¯´æ‚¨åœ¨è¿™ä¸ªé¡¹ç›®ä¸­é‡åˆ°çš„æœ€å¤§æŒ‘æˆ˜æ˜¯ä»€ä¹ˆå—ï¼Ÿ',
      'æ‚¨æ˜¯å¦‚ä½•è§£å†³è¿™ä¸ªæŠ€æœ¯éš¾é¢˜çš„ï¼Ÿ',
      'åœ¨å›¢é˜Ÿåä½œä¸­ï¼Œæ‚¨é€šå¸¸æ‰®æ¼”ä»€ä¹ˆè§’è‰²ï¼Ÿ',
      'æ‚¨å¯¹è¿™ä¸ªæŠ€æœ¯æ ˆçš„æœªæ¥å‘å±•æœ‰ä»€ä¹ˆçœ‹æ³•ï¼Ÿ',
    ];
    
    return fallbackQuestions[Math.floor(Math.random() * fallbackQuestions.length)];
  }
}
```

#### ä»»åŠ¡2.3: å®æ—¶æƒ…æ„Ÿåˆ†æ (2åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/ai/emotion-analyzer.ts
export class EmotionAnalyzer {
  // åˆ†ææ–‡æœ¬æƒ…æ„Ÿ
  analyzeSentiment(text: string): EmotionAnalysis {
    // ç®€åŒ–ç‰ˆæƒ…æ„Ÿåˆ†æ
    const positiveWords = ['å¥½', 'æ£’', 'ä¼˜ç§€', 'å–œæ¬¢', 'æ»¡æ„', 'æˆåŠŸ', 'é¡ºåˆ©'];
    const negativeWords = ['å·®', 'ç³Ÿç³•', 'å›°éš¾', 'å¤±è´¥', 'é—®é¢˜', 'æŒ‘æˆ˜', 'ä¸å¥½'];
    const confidenceWords = ['ç¡®å®š', 'è‚¯å®š', 'å½“ç„¶', 'ç»å¯¹', 'ä¸€å®š', 'å¿…é¡»'];
    const uncertainWords = ['å¯èƒ½', 'ä¹Ÿè®¸', 'å¤§æ¦‚', 'åº”è¯¥', 'æˆ–è®¸', 'ä¸ç¡®å®š'];
    
    const words = text.toLowerCase().split(/\s+/);
    
    let positiveScore = 0;
    let negativeScore = 0;
    let confidenceScore = 0;
    let uncertaintyScore = 0;
    
    words.forEach(word => {
      if (positiveWords.some(pw => word.includes(pw))) positiveScore++;
      if (negativeWords.some(nw => word.includes(nw))) negativeScore++;
      if (confidenceWords.some(cw => word.includes(cw))) confidenceScore++;
      if (uncertainWords.some(uw => word.includes(uw))) uncertaintyScore++;
    });
    
    const totalWords = words.length;
    
    return {
      sentiment: (positiveScore - negativeScore) / totalWords,
      confidence: (confidenceScore - uncertaintyScore) / totalWords,
      emotions: {
        positive: positiveScore / totalWords,
        negative: negativeScore / totalWords,
        neutral: 1 - (positiveScore + negativeScore) / totalWords,
      },
      keywords: this.extractEmotionalKeywords(text),
    };
  }
  
  // æå–æƒ…æ„Ÿå…³é”®è¯
  private extractEmotionalKeywords(text: string): string[] {
    const emotionalWords = text.match(/\b(å¾ˆ|éå¸¸|ç‰¹åˆ«|æå…¶|ç›¸å½“|æ¯”è¾ƒ)\s*\w+/g) || [];
    return emotionalWords.slice(0, 5); // æœ€å¤šè¿”å›5ä¸ª
  }
  
  // è¯„ä¼°å›ç­”è´¨é‡
  assessAnswerQuality(text: string): AnswerQuality {
    const wordCount = text.split(/\s+/).length;
    const sentenceCount = text.split(/[.!?ã€‚ï¼ï¼Ÿ]/).length;
    const avgWordsPerSentence = wordCount / sentenceCount;
    
    // æŠ€æœ¯è¯æ±‡æ£€æµ‹
    const technicalWords = this.detectTechnicalTerms(text);
    
    return {
      length: this.categorizeLength(wordCount),
      complexity: this.categorizeComplexity(avgWordsPerSentence),
      technicalDepth: technicalWords.length,
      clarity: this.assessClarity(text),
      completeness: this.assessCompleteness(text),
    };
  }
  
  private categorizeLength(wordCount: number): 'short' | 'medium' | 'long' {
    if (wordCount < 20) return 'short';
    if (wordCount < 100) return 'medium';
    return 'long';
  }
  
  private categorizeComplexity(avgWords: number): 'simple' | 'moderate' | 'complex' {
    if (avgWords < 8) return 'simple';
    if (avgWords < 15) return 'moderate';
    return 'complex';
  }
  
  private detectTechnicalTerms(text: string): string[] {
    const techTerms = [
      'API', 'REST', 'GraphQL', 'microservice', 'database', 'algorithm',
      'framework', 'library', 'component', 'module', 'interface',
      'async', 'await', 'promise', 'callback', 'event', 'handler'
    ];
    
    return techTerms.filter(term => 
      text.toLowerCase().includes(term.toLowerCase())
    );
  }
  
  private assessClarity(text: string): number {
    // ç®€åŒ–ç‰ˆæ¸…æ™°åº¦è¯„ä¼°
    const clarityIndicators = ['é¦–å…ˆ', 'ç„¶å', 'æœ€å', 'å› ä¸º', 'æ‰€ä»¥', 'ä¾‹å¦‚'];
    const indicatorCount = clarityIndicators.filter(indicator => 
      text.includes(indicator)
    ).length;
    
    return Math.min(indicatorCount / 3, 1); // æ ‡å‡†åŒ–åˆ°0-1
  }
  
  private assessCompleteness(text: string): number {
    // ç®€åŒ–ç‰ˆå®Œæ•´æ€§è¯„ä¼°
    const completenessMarkers = ['èƒŒæ™¯', 'è¿‡ç¨‹', 'ç»“æœ', 'å­¦åˆ°', 'æ”¹è¿›'];
    const markerCount = completenessMarkers.filter(marker => 
      text.includes(marker)
    ).length;
    
    return Math.min(markerCount / 3, 1); // æ ‡å‡†åŒ–åˆ°0-1
  }
}
```

### Phase 3: é›†æˆæµ‹è¯•ä¸ä¼˜åŒ– (10åˆ†é’Ÿ)

#### ä»»åŠ¡3.1: ç«¯åˆ°ç«¯æµ‹è¯• (5åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/ai/__tests__/integration.test.ts
describe('AI Integration End-to-End Tests', () => {
  let promptxClient: PromptXMCPClient;
  let nuwaManager: NuwaRoleManager;
  let interviewerGenerator: InterviewerGenerator;
  
  beforeAll(async () => {
    promptxClient = new PromptXMCPClient();
    await promptxClient.connect();
    
    nuwaManager = new NuwaRoleManager(promptxClient);
    await nuwaManager.activateNuwa();
    
    interviewerGenerator = new InterviewerGenerator(nuwaManager);
  });
  
  test('should generate interviewer successfully', async () => {
    const jobReq: JobRequirement = {
      position: 'Pythonåç«¯å·¥ç¨‹å¸ˆ',
      experience: '5å¹´',
      skills: ['Python', 'Django', 'MySQL', 'Redis'],
      level: 'senior',
      description: 'è´Ÿè´£åç«¯APIå¼€å‘å’Œæ•°æ®åº“è®¾è®¡',
    };
    
    const interviewer = await interviewerGenerator.generateInterviewer(jobReq);
    
    expect(interviewer).toBeDefined();
    expect(interviewer.name).toBeTruthy();
    expect(interviewer.background).toBeTruthy();
    expect(interviewer.expertise.length).toBeGreaterThan(0);
    expect(interviewer.questions.length).toBeGreaterThan(0);
  });
  
  test('should handle conversation flow', async () => {
    const interviewer = await interviewerGenerator.generateInterviewer({
      position: 'Frontend Developer',
      experience: '3å¹´',
      skills: ['React', 'TypeScript'],
      level: 'mid',
      description: 'Reactå‰ç«¯å¼€å‘',
    });
    
    const conversationManager = new ConversationManager(interviewer);
    const followUpGenerator = new FollowUpGenerator(conversationManager, promptxClient);
    
    // æ¨¡æ‹Ÿå¯¹è¯
    const candidateResponse = 'æˆ‘æœ‰3å¹´Reactå¼€å‘ç»éªŒï¼Œä¸»è¦è´Ÿè´£ä¼ä¸šçº§åº”ç”¨çš„å‰ç«¯å¼€å‘ã€‚';
    
    conversationManager.addMessage({
      id: 'msg1',
      role: 'candidate',
      content: candidateResponse,
      timestamp: new Date(),
    });
    
    const followUp = await followUpGenerator.generateFollowUp(candidateResponse);
    
    expect(followUp).toBeTruthy();
    expect(followUp.length).toBeGreaterThan(10);
  });
});
```

#### ä»»åŠ¡3.2: æ€§èƒ½ä¼˜åŒ– (3åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/ai/performance-optimizer.ts
export class AIPerformanceOptimizer {
  private cache = new Map<string, any>();
  private requestQueue: Array<() => Promise<any>> = [];
  private isProcessing = false;
  
  // ç¼“å­˜ç®¡ç†
  setCacheItem(key: string, value: any, ttl: number = 300000): void {
    const expiry = Date.now() + ttl;
    this.cache.set(key, { value, expiry });
  }
  
  getCacheItem(key: string): any | null {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }
  
  // è¯·æ±‚é˜Ÿåˆ—ç®¡ç†
  async queueRequest<T>(requestFn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.requestQueue.push(async () => {
        try {
          const result = await requestFn();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      this.processQueue();
    });
  }
  
  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.requestQueue.length === 0) return;
    
    this.isProcessing = true;
    
    while (this.requestQueue.length > 0) {
      const request = this.requestQueue.shift();
      if (request) {
        await request();
        // æ·»åŠ å°å»¶è¿Ÿé¿å…APIé™æµ
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    this.isProcessing = false;
  }
  
  // é¢„åŠ è½½ä¼˜åŒ–
  async preloadInterviewerTemplates(): Promise<void> {
    const commonPositions = [
      'Frontend Developer',
      'Backend Developer',
      'Full Stack Developer',
      'Data Scientist',
      'Product Manager',
    ];
    
    const preloadPromises = commonPositions.map(position => 
      this.queueRequest(async () => {
        const cacheKey = `template_${position}`;
        if (!this.getCacheItem(cacheKey)) {
          // é¢„ç”Ÿæˆæ¨¡æ¿
          const template = await this.generateInterviewerTemplate(position);
          this.setCacheItem(cacheKey, template, 3600000); // 1å°æ—¶ç¼“å­˜
        }
      })
    );
    
    await Promise.all(preloadPromises);
  }
  
  private async generateInterviewerTemplate(position: string): Promise<any> {
    // ç”Ÿæˆé¢è¯•å®˜æ¨¡æ¿çš„ç®€åŒ–ç‰ˆæœ¬
    return {
      position,
      commonQuestions: this.getCommonQuestions(position),
      skillKeywords: this.getSkillKeywords(position),
    };
  }
  
  private getCommonQuestions(position: string): string[] {
    const questionMap: Record<string, string[]> = {
      'Frontend Developer': [
        'è¯·ä»‹ç»ä¸€ä¸‹æ‚¨æœ€å¤æ‚çš„å‰ç«¯é¡¹ç›®',
        'å¦‚ä½•ä¼˜åŒ–Reactåº”ç”¨çš„æ€§èƒ½ï¼Ÿ',
        'è°ˆè°ˆæ‚¨å¯¹ç°ä»£å‰ç«¯æ¡†æ¶çš„ç†è§£',
      ],
      'Backend Developer': [
        'è¯·æè¿°æ‚¨è®¾è®¡è¿‡çš„æœ€å¤æ‚çš„API',
        'å¦‚ä½•å¤„ç†é«˜å¹¶å‘åœºæ™¯ï¼Ÿ',
        'æ•°æ®åº“ä¼˜åŒ–æœ‰å“ªäº›ç­–ç•¥ï¼Ÿ',
      ],
    };
    
    return questionMap[position] || [];
  }
  
  private getSkillKeywords(position: string): string[] {
    const skillMap: Record<string, string[]> = {
      'Frontend Developer': ['React', 'Vue', 'Angular', 'TypeScript', 'CSS', 'HTML'],
      'Backend Developer': ['Node.js', 'Python', 'Java', 'Database', 'API', 'Microservices'],
    };
    
    return skillMap[position] || [];
  }
}
```

#### ä»»åŠ¡3.3: é”™è¯¯å¤„ç†ä¸é™çº§ (2åˆ†é’Ÿ)
**æ‰§è¡Œæ­¥éª¤**:
```typescript
// src/lib/ai/error-handler.ts
export class AIErrorHandler {
  private fallbackResponses: Map<string, string> = new Map();
  
  constructor() {
    this.initializeFallbacks();
  }
  
  private initializeFallbacks(): void {
    this.fallbackResponses.set('generation_failed', 'æŠ±æ­‰ï¼ŒAIé¢è¯•å®˜ç”Ÿæˆé‡åˆ°é—®é¢˜ï¼Œè¯·ç¨åé‡è¯•ã€‚');
    this.fallbackResponses.set('connection_failed', 'PromptXè¿æ¥å¼‚å¸¸ï¼Œæ­£åœ¨å°è¯•é‡æ–°è¿æ¥...');
    this.fallbackResponses.set('timeout', 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚');
    this.fallbackResponses.set('rate_limit', 'APIè°ƒç”¨é¢‘ç‡è¿‡é«˜ï¼Œè¯·ç¨åå†è¯•ã€‚');
  }
  
  // å¤„ç†AIç›¸å…³é”™è¯¯
  handleAIError(error: Error, context: string): AIErrorResponse {
    console.error(`AI Error in ${context}:`, error);
    
    const errorType = this.classifyError(error);
    const fallbackMessage = this.fallbackResponses.get(errorType) || 'ç³»ç»Ÿé‡åˆ°æœªçŸ¥é”™è¯¯';
    
    return {
      type: errorType,
      message: fallbackMessage,
      canRetry: this.canRetry(errorType),
      fallbackAction: this.getFallbackAction(errorType),
    };
  }
  
  private classifyError(error: Error): string {
    if (error.message.includes('timeout')) return 'timeout';
    if (error.message.includes('rate limit')) return 'rate_limit';
    if (error.message.includes('connection')) return 'connection_failed';
    if (error.message.includes('generation')) return 'generation_failed';
    return 'unknown';
  }
  
  private canRetry(errorType: string): boolean {
    const retryableErrors = ['timeout', 'connection_failed', 'rate_limit'];
    return retryableErrors.includes(errorType);
  }
  
  private getFallbackAction(errorType: string): string {
    const actionMap: Record<string, string> = {
      'generation_failed': 'use_template',
      'connection_failed': 'retry_connection',
      'timeout': 'retry_request',
      'rate_limit': 'wait_and_retry',
    };
    
    return actionMap[errorType] || 'manual_intervention';
  }
}
```

## ğŸ¯ è´¨é‡æ ‡å‡† (ä¸å¯é™ä½)

### AIé›†æˆè´¨é‡æ ‡å‡†
- âœ… PromptX MCPè¿æ¥æˆåŠŸç‡ â‰¥ 99%
- âœ… å¥³å¨²è§’è‰²æ¿€æ´»æ—¶é—´ â‰¤ 5ç§’
- âœ… é¢è¯•å®˜ç”ŸæˆæˆåŠŸç‡ â‰¥ 95%
- âœ… å¯¹è¯å“åº”æ—¶é—´ â‰¤ 3ç§’

### æ™ºèƒ½åŒ–æ°´å¹³æ ‡å‡†
- âœ… é¢è¯•å®˜ç”Ÿæˆè´¨é‡ä¸“ä¸šåº¦ â‰¥ 8/10
- âœ… è¿½é—®é—®é¢˜ç›¸å…³æ€§ â‰¥ 85%
- âœ… æƒ…æ„Ÿåˆ†æå‡†ç¡®ç‡ â‰¥ 80%
- âœ… ä¸Šä¸‹æ–‡è®°å¿†ä¿æŒ â‰¥ 10è½®å¯¹è¯

### æ€§èƒ½æ ‡å‡†
- âœ… APIè°ƒç”¨å¹¶å‘å¤„ç† â‰¥ 10ä¸ª/ç§’
- âœ… ç¼“å­˜å‘½ä¸­ç‡ â‰¥ 70%
- âœ… å†…å­˜ä½¿ç”¨ â‰¤ 100MB
- âœ… é”™è¯¯æ¢å¤æ—¶é—´ â‰¤ 2ç§’

## ğŸš¨ é£é™©é¢„æ¡ˆ

### å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ
1. **PromptXè¿æ¥å¤±è´¥**: è‡ªåŠ¨é‡è¯•æœºåˆ¶ + é™çº§åˆ°æœ¬åœ°æ¨¡æ¿
2. **å¥³å¨²è§’è‰²æ¿€æ´»å¤±è´¥**: é‡æ–°æ¿€æ´» + å¤‡ç”¨è§’è‰²æ–¹æ¡ˆ
3. **ç”Ÿæˆè´¨é‡ä¸ä½³**: æç¤ºè¯ä¼˜åŒ– + åå¤„ç†å¢å¼º
4. **APIé™æµ**: è¯·æ±‚é˜Ÿåˆ— + æŒ‡æ•°é€€é¿é‡è¯•

### ç´§æ€¥è”ç³»
- é‡åˆ°PromptXé›†æˆé—®é¢˜ï¼Œç«‹å³è”ç³»é¡¹ç›®è´Ÿè´£äºº
- å‘ç°AIç”Ÿæˆè´¨é‡é—®é¢˜ï¼ŒåŠæ—¶è°ƒæ•´å‚æ•°
- ä¸å…è®¸ä¸ºäº†èµ¶æ—¶é—´è€Œé™ä½AIæ™ºèƒ½åŒ–æ°´å¹³

## âœ… å®Œæˆæ£€æŸ¥æ¸…å•

- [ ] PromptX MCPè¿æ¥å»ºç«‹æˆåŠŸ
- [ ] å¥³å¨²è§’è‰²æ¿€æ´»æ­£å¸¸
- [ ] AIé¢è¯•å®˜ç”ŸæˆåŠŸèƒ½å®Œæ•´
- [ ] å¯¹è¯ä¸Šä¸‹æ–‡ç®¡ç†æ­£å¸¸
- [ ] æ™ºèƒ½è¿½é—®é€»è¾‘æœ‰æ•ˆ
- [ ] æƒ…æ„Ÿåˆ†æåŠŸèƒ½å‡†ç¡®
- [ ] æ€§èƒ½ä¼˜åŒ–æªæ–½åˆ°ä½
- [ ] é”™è¯¯å¤„ç†æœºåˆ¶å®Œå–„
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡
- [ ] æ‰€æœ‰è´¨é‡æ ‡å‡†è¾¾æ ‡
